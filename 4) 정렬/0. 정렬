정렬(sort)
    - 목록(list)에 포함된 원소들을 일정한 순서에 따라 재배치하는 것
    - 정렬의 기준이 되는 속성값: 키(key)
    - 버블 정렬, 선택 정렬, 삽입 정렬 등

1. 버블정렬(bubble sort)
    - 두 인접한 원소 간의 비교와 교환의 과정을 반복하는 정렬 알고리즘
    - 장점: 비교적 쉽게 이해할 수 있고 구현이 쉽다.
    - 단점: 비교 및 교환 횟수가 많아 수행 시간이 느리다.

    - 특징:
    맨 앞 원소 비교, 큰 값 뒤로 > 마지막 원소까지 반복 > '뒤쪽부터 정렬'

    - 시간복잡도 O(n^2)

    - 최선의 경우: 이미 정렬
    - 최악의 경우: 거꾸로 정렬

2. 선택정렬 (selection sort)
    - 원소중에서 최소값을 찾아 맨 앞의 원소와 교체하는 과정을 반복하는 정렬 알고리즘
    - 장점: 구현이 쉽다. 버블정렬의 교체횟수를 줄일 수 있다.
    - 단점: 수행 시간이 느리다.

    - 특징:
    '앞쪽부터 정렬'
    최솟값 '선택'이 핵심.

    - 시간복잡도 O(n^2)

    - 최선의 경우: 
    - 최악의 경우: 

3. 삽입정렬 (insertion sort)
    - 원소를 1개씩 삽입하는 과정을 반복하는 정렬 알고리즘
    - 장점: 구현이 쉽다. 부분적으로 정렬된 자료에 대해 효율적으로 작동한다.
    - 단점: 수행 시간이 느리다.

    - 특징:
    '앞쪽부터 정렬'
    부분적으로 정렬된 자료에 적합. ex. 번호순학습지
    퀵 정렬과 함께 사용하여 효과적.

    - 시간복잡도 O(n^2)
    최선의 경우(이미정렬) O(n)

    - 최선의 경우: 이미정렬
    - 최악의 경우: 

4. 퀵 정렬 (quick sort)
    - 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
    - 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
    - 장점: 일반적인 상황에서 n개의 원소를 정렬하는 가장 빠른 알고리즘
    - 단점: 피벗 값 설정 문제, 원소 적은 경우 분할연산/재귀호출에 따른 불필요한 시간 낭비

    - 특징:
    피벗값 선택 > 피벗과의 크기 비교를 통해 나머지 원소 분할 > 재귀적 반복
    분할정복
    피벗값 설정이 핵심
    삽입정렬과 함께 사용(원소 적은 경우)

    - 시간복잡도: O(nlogn)

    - 최선의 경우: 
    - 최악의 경우: 이미 정렬됨>피벗1 O(n^2), 피벗이 끝값

5. 힙정렬 (heap sort)
    - 최대 힙 제작 >> 루트노드, 마지막 노드 교환
    
    - 특징: 힙트리 구축, 완전 2진 트리, 일종의 선택 정렬(비선형), 최대/최소 힙
    
    - 시간복잡도:
    1. 최대힙: O(logn)
    2. 정렬: O(n)
    3. 힙정렬: O(nlogn)

    - 최선의 경우: 
    - 최악의 경우: 